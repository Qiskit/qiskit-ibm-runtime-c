/* automatically generated by rust-bindgen 0.71.1 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 1;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 1;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _COMPLEX_H: u32 = 1;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
pub type __cfloat128 = __BindgenComplex<u128>;
pub type _Float128 = u128;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
    pub __unused_initialized_1: ::std::os::raw::c_uint,
    pub __unused_initialized_2: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 16usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 28usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 32usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_1"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_1) - 40usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_2"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_2) - 44usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cacos(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cacos(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casin(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __casin(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catan(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __catan(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccos(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ccos(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csin(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csin(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctan(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ctan(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cacosh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cacosh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casinh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __casinh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catanh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __catanh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccosh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ccosh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csinh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csinh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctanh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ctanh(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cexp(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cexp(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn clog(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __clog(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cpow(__x: __BindgenComplex<f64>, __y: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cpow(__x: __BindgenComplex<f64>, __y: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csqrt(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csqrt(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cabs(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn __cabs(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn carg(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn __carg(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn conj(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __conj(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cproj(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cproj(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cimag(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn __cimag(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn creal(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn __creal(__z: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn cacosf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __cacosf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn casinf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __casinf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn catanf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __catanf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ccosf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __ccosf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csinf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __csinf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ctanf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __ctanf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cacoshf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __cacoshf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn casinhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __casinhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn catanhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __catanhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ccoshf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __ccoshf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csinhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __csinhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ctanhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __ctanhf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cexpf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __cexpf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn clogf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __clogf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cpowf(__x: __BindgenComplex<f32>, __y: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __cpowf(__x: __BindgenComplex<f32>, __y: __BindgenComplex<f32>)
        -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csqrtf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __csqrtf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cabsf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn __cabsf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn cargf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn __cargf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn conjf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __conjf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cprojf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn __cprojf(__z: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cimagf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn __cimagf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn crealf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn __crealf(__z: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn cacosl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cacosl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casinl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __casinl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catanl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __catanl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccosl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ccosl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csinl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csinl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctanl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ctanl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cacoshl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cacoshl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casinhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __casinhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catanhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __catanhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccoshl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ccoshl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csinhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csinhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctanhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __ctanhl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cexpl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cexpl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn clogl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __clogl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cpowl(__x: __BindgenComplex<f64>, __y: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cpowl(__x: __BindgenComplex<f64>, __y: __BindgenComplex<f64>)
        -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csqrtl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __csqrtl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cabsl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn __cabsl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn cargl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn __cargl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn conjl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __conjl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cprojl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn __cprojl(__z: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cimagl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn __cimagl(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn creall(__z: __BindgenComplex<f64>) -> u128;
}
unsafe extern "C" {
    pub fn __creall(__z: __BindgenComplex<f64>) -> u128;
}
pub type QkComplex32 = __BindgenComplex<f32>;
pub type QkComplex64 = __BindgenComplex<f64>;
#[doc = " Pauli X operator."]
pub const QkBitTerm_QkBitTerm_X: QkBitTerm = 2;
#[doc = " Projector to the positive eigenstate of Pauli X."]
pub const QkBitTerm_QkBitTerm_Plus: QkBitTerm = 10;
#[doc = " Projector to the negative eigenstate of Pauli X."]
pub const QkBitTerm_QkBitTerm_Minus: QkBitTerm = 6;
#[doc = " Pauli Y operator."]
pub const QkBitTerm_QkBitTerm_Y: QkBitTerm = 3;
#[doc = " Projector to the positive eigenstate of Pauli Y."]
pub const QkBitTerm_QkBitTerm_Right: QkBitTerm = 11;
#[doc = " Projector to the negative eigenstate of Pauli Y."]
pub const QkBitTerm_QkBitTerm_Left: QkBitTerm = 7;
#[doc = " Pauli Z operator."]
pub const QkBitTerm_QkBitTerm_Z: QkBitTerm = 1;
#[doc = " Projector to the positive eigenstate of Pauli Z."]
pub const QkBitTerm_QkBitTerm_Zero: QkBitTerm = 9;
#[doc = " Projector to the negative eigenstate of Pauli Z."]
pub const QkBitTerm_QkBitTerm_One: QkBitTerm = 5;
pub type QkBitTerm = u8;
#[doc = " Success."]
pub const QkExitCode_QkExitCode_Success: QkExitCode = 0;
#[doc = " Error related to data input."]
pub const QkExitCode_QkExitCode_CInputError: QkExitCode = 100;
#[doc = " Unexpected null pointer."]
pub const QkExitCode_QkExitCode_NullPointerError: QkExitCode = 101;
#[doc = " Pointer is not aligned to expected data."]
pub const QkExitCode_QkExitCode_AlignmentError: QkExitCode = 102;
#[doc = " Index out of bounds."]
pub const QkExitCode_QkExitCode_IndexError: QkExitCode = 103;
#[doc = " Error related to arithmetic operations or similar."]
pub const QkExitCode_QkExitCode_ArithmeticError: QkExitCode = 200;
#[doc = " Mismatching number of qubits."]
pub const QkExitCode_QkExitCode_MismatchedQubits: QkExitCode = 201;
pub type QkExitCode = u32;
pub const QkGate_QkGate_GlobalPhase: QkGate = 0;
pub const QkGate_QkGate_H: QkGate = 1;
pub const QkGate_QkGate_I: QkGate = 2;
pub const QkGate_QkGate_X: QkGate = 3;
pub const QkGate_QkGate_Y: QkGate = 4;
pub const QkGate_QkGate_Z: QkGate = 5;
pub const QkGate_QkGate_Phase: QkGate = 6;
pub const QkGate_QkGate_R: QkGate = 7;
pub const QkGate_QkGate_RX: QkGate = 8;
pub const QkGate_QkGate_RY: QkGate = 9;
pub const QkGate_QkGate_RZ: QkGate = 10;
pub const QkGate_QkGate_S: QkGate = 11;
pub const QkGate_QkGate_Sdg: QkGate = 12;
pub const QkGate_QkGate_SX: QkGate = 13;
pub const QkGate_QkGate_SXdg: QkGate = 14;
pub const QkGate_QkGate_T: QkGate = 15;
pub const QkGate_QkGate_Tdg: QkGate = 16;
pub const QkGate_QkGate_U: QkGate = 17;
pub const QkGate_QkGate_U1: QkGate = 18;
pub const QkGate_QkGate_U2: QkGate = 19;
pub const QkGate_QkGate_U3: QkGate = 20;
pub const QkGate_QkGate_CH: QkGate = 21;
pub const QkGate_QkGate_CX: QkGate = 22;
pub const QkGate_QkGate_CY: QkGate = 23;
pub const QkGate_QkGate_CZ: QkGate = 24;
pub const QkGate_QkGate_DCX: QkGate = 25;
pub const QkGate_QkGate_ECR: QkGate = 26;
pub const QkGate_QkGate_Swap: QkGate = 27;
pub const QkGate_QkGate_ISwap: QkGate = 28;
pub const QkGate_QkGate_CPhase: QkGate = 29;
pub const QkGate_QkGate_CRX: QkGate = 30;
pub const QkGate_QkGate_CRY: QkGate = 31;
pub const QkGate_QkGate_CRZ: QkGate = 32;
pub const QkGate_QkGate_CS: QkGate = 33;
pub const QkGate_QkGate_CSdg: QkGate = 34;
pub const QkGate_QkGate_CSX: QkGate = 35;
pub const QkGate_QkGate_CU: QkGate = 36;
pub const QkGate_QkGate_CU1: QkGate = 37;
pub const QkGate_QkGate_CU3: QkGate = 38;
pub const QkGate_QkGate_RXX: QkGate = 39;
pub const QkGate_QkGate_RYY: QkGate = 40;
pub const QkGate_QkGate_RZZ: QkGate = 41;
pub const QkGate_QkGate_RZX: QkGate = 42;
pub const QkGate_QkGate_XXMinusYY: QkGate = 43;
pub const QkGate_QkGate_XXPlusYY: QkGate = 44;
pub const QkGate_QkGate_CCX: QkGate = 45;
pub const QkGate_QkGate_CCZ: QkGate = 46;
pub const QkGate_QkGate_CSwap: QkGate = 47;
pub const QkGate_QkGate_RCCX: QkGate = 48;
pub const QkGate_QkGate_C3X: QkGate = 49;
pub const QkGate_QkGate_C3SX: QkGate = 50;
pub const QkGate_QkGate_RC3X: QkGate = 51;
pub type QkGate = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCount {
    pub name: *const ::std::os::raw::c_char,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCount"][::std::mem::size_of::<QkOpCount>() - 16usize];
    ["Alignment of QkOpCount"][::std::mem::align_of::<QkOpCount>() - 8usize];
    ["Offset of field: QkOpCount::name"][::std::mem::offset_of!(QkOpCount, name) - 0usize];
    ["Offset of field: QkOpCount::count"][::std::mem::offset_of!(QkOpCount, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCounts {
    pub data: *mut QkOpCount,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCounts"][::std::mem::size_of::<QkOpCounts>() - 16usize];
    ["Alignment of QkOpCounts"][::std::mem::align_of::<QkOpCounts>() - 8usize];
    ["Offset of field: QkOpCounts::data"][::std::mem::offset_of!(QkOpCounts, data) - 0usize];
    ["Offset of field: QkOpCounts::len"][::std::mem::offset_of!(QkOpCounts, len) - 8usize];
};
#[doc = " @ingroup QkCircuit\n\n A circuit instruction representation.\n\n This struct represents the data contained in an individual instruction in a ``QkCircuit``.\n It is not a pointer to the underlying object, but contains a copy of the properties of the\n instruction for inspection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuitInstruction {
    #[doc = " The instruction name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The number of qubits for this instruction."]
    pub num_qubits: u32,
    #[doc = " A pointer to an array of qubit indices this instruction operates on."]
    pub qubits: *mut u32,
    #[doc = " The number of clbits for this instruction."]
    pub num_clbits: u32,
    #[doc = " A pointer to an array of clbit indices this instruction operates on."]
    pub clbits: *mut u32,
    #[doc = " The number of parameters for this instruction."]
    pub num_params: u32,
    #[doc = " A pointer to an array of parameter values for this instruction."]
    pub params: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkCircuitInstruction"][::std::mem::size_of::<QkCircuitInstruction>() - 56usize];
    ["Alignment of QkCircuitInstruction"][::std::mem::align_of::<QkCircuitInstruction>() - 8usize];
    ["Offset of field: QkCircuitInstruction::name"]
        [::std::mem::offset_of!(QkCircuitInstruction, name) - 0usize];
    ["Offset of field: QkCircuitInstruction::num_qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_qubits) - 8usize];
    ["Offset of field: QkCircuitInstruction::qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, qubits) - 16usize];
    ["Offset of field: QkCircuitInstruction::num_clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_clbits) - 24usize];
    ["Offset of field: QkCircuitInstruction::clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, clbits) - 32usize];
    ["Offset of field: QkCircuitInstruction::num_params"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_params) - 40usize];
    ["Offset of field: QkCircuitInstruction::params"]
        [::std::mem::offset_of!(QkCircuitInstruction, params) - 48usize];
};
#[doc = " A term in a ``QkObs``.\n\n This contains the coefficient (``coeff``), the number of qubits of the observable\n (``num_qubits``) and pointers to the ``bit_terms`` and ``indices`` arrays, which have\n length ``len``. It's the responsibility of the user that the data is coherent,\n see also the below section on safety.\n\n # Safety\n\n * ``bit_terms`` must be a non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``.\n * ``indices`` must be a non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObsTerm {
    #[doc = " The coefficient of the observable term."]
    pub coeff: QkComplex64,
    #[doc = " Length of the ``bit_terms`` and ``indices`` arrays."]
    pub len: usize,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``."]
    pub bit_terms: *mut QkBitTerm,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
    pub indices: *mut u32,
    #[doc = " The number of qubits the observable term is defined on."]
    pub num_qubits: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkObsTerm"][::std::mem::size_of::<QkObsTerm>() - 48usize];
    ["Alignment of QkObsTerm"][::std::mem::align_of::<QkObsTerm>() - 8usize];
    ["Offset of field: QkObsTerm::coeff"][::std::mem::offset_of!(QkObsTerm, coeff) - 0usize];
    ["Offset of field: QkObsTerm::len"][::std::mem::offset_of!(QkObsTerm, len) - 16usize];
    ["Offset of field: QkObsTerm::bit_terms"]
        [::std::mem::offset_of!(QkObsTerm, bit_terms) - 24usize];
    ["Offset of field: QkObsTerm::indices"][::std::mem::offset_of!(QkObsTerm, indices) - 32usize];
    ["Offset of field: QkObsTerm::num_qubits"]
        [::std::mem::offset_of!(QkObsTerm, num_qubits) - 40usize];
};
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Construct a new circuit with the given number of qubits and clbits.\n\n @param num_qubits The number of qubits the circuit contains.\n @param num_clbits The number of clbits the circuit contains.\n\n @return A pointer to the created circuit.\n\n # Example\n\n     QkCircuit *empty = qk_circuit_new(100, 100);\n"]
    pub fn qk_circuit_new(num_qubits: u32, num_clbits: u32) -> *mut QkCircuit;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     uint32_t num_qubits = qk_circuit_num_qubits(qc);  // num_qubits==100\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_qubits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of clbits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 50);\n     uint32_t num_clbits = qk_circuit_num_clbits(qc);  // num_clbits==50\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_clbits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free the circuit.\n\n @param circuit A pointer to the circuit to free.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 100);\n     qk_circuit_free(qc);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not either null or a valid pointer to a\n [CircuitData]."]
    pub fn qk_circuit_free(circuit: *mut QkCircuit);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a standard gate to the circuit.\n\n @param circuit A pointer to the circuit to add the gate to.\n @param gate The StandardGate to add to the circuit.\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the gate on. This\n     can be a null pointer if there are no qubits for `gate` (e.g. `QkGate_GlobalPhase`)\n @param params The pointer to the array of ``double`` values to use for the gate parameters.\n     This can be a null pointer if there are no parameters for `gate` (e.g. `QkGate_H`).\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, HGate, *[0], *[]);\n\n # Safety\n\n The ``qubits`` and ``params`` types are expected to be a pointer to an array of ``uint32_t``\n and ``double`` respectively where the length is matching the expectations for the standard\n gate. If the array is insufficently long the behavior of this function is undefined as this\n will read outside the bounds of the array. It can be a null pointer if there are no qubits\n or params for a given gate. You can check `qk_gate_num_qubits` and `qk_gate_num_params` to\n determine how many qubits and params are required for a given gate.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_gate(
        circuit: *mut QkCircuit,
        gate: QkGate,
        qubits: *const u32,
        params: *const f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits for a `QkGate`\n\n @param gate The standard gate to get the number of qubits for\n\n # Example\n\n     uint32_t num_qubits = qk_gate_num_qubits(QkGate_CCX);\n"]
    pub fn qk_gate_num_qubits(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of params for a `QkGate`\n\n @param gate The standard gate to get the number of qubits for\n\n # Example\n\n     uint32_t num_params = qk_gate_num_params(QkGate_R);\n"]
    pub fn qk_gate_num_params(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a measurement to the circuit\n\n @param circuit A pointer to the circuit to add the measurement to\n @param qubits The ``uint32_t`` for the qubit to measure\n @param clbits The ``uint32_t`` for the clbit to store the measurement outcome in\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 1);\n     qk_circuit_measure(qc, 0, 0);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_measure(circuit: *mut QkCircuit, qubit: u32, clbit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a reset to the circuit\n\n @param circuit A pointer to the circuit to add the reset to\n @param qubits The ``uint32_t`` for the qubit to reset\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_reset(qc, 0);\n\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_reset(circuit: *mut QkCircuit, qubit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a barrier to the circuit\n\n @param circuit A pointer to the circuit to add the barrier to\n @param num_qubits The number of qubits wide the barrier is\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the barrier on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     uint32_t qubits[5] = {0, 1, 2, 3, 4};\n     qk_circuit_barrier(qc, 5, qubits);\n\n # Safety\n\n The length of the array qubits points to must be num_qubits. If there is\n a mismatch the behavior is undefined.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_barrier(
        circuit: *mut QkCircuit,
        num_qubits: u32,
        qubits: *const u32,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return a list of string names for instructions in a circuit and their counts.\n\n @param circuit A pointer to the circuit to get the counts for.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, HGate, *[0], *[]);\n     qk_circuit_count_ops(qc);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_count_ops(circuit: *const QkCircuit) -> QkOpCounts;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the number of instructions in the circuit\n\n @param circuit A pointer to the circuit to get the total number of instructions for.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, QkGate_H, *[0], *[]);\n     qk_circuit_num_instructions(qc); // 1\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_instructions(circuit: *const QkCircuit) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the instruction details for an instruction in the circuit\n\n This function is used to get the instruction details for a given instruction in\n the circuit. It returns\n\n @param circuit A pointer to the circuit to get the instruction details for.\n @param index The instruction index to get the instruction details of.\n\n @return The instruction details for the specified instructions\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, QkGate_H, *[0], *[]);\n     QkCircuitInstruction inst = qk_circuit_get_instruction(qc, 0);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``. The\n value for ``index`` must be less than the value returned by `qk_circuit_num_instructions`\n otherwise this function will panic"]
    pub fn qk_circuit_get_instruction(
        circuit: *const QkCircuit,
        index: usize,
    ) -> QkCircuitInstruction;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free a circuit instruction object\n\n @param inst The instruction to free\n\n # Safety\n Behavior is undefined if ``inst`` is not an object returned by ``qk_circuit_get_instruction``."]
    pub fn qk_circuit_instruction_free(inst: QkCircuitInstruction);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free a circuit op count list.\n\n @param op_counts The returned op count list from ``qk_circuit_count_ops``.\n\n # Safety\n\n Behavior is undefined if ``op_counts`` is not the object returned by ``qk_circuit_count_ops``."]
    pub fn qk_opcounts_free(op_counts: QkOpCounts);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the zero observable (without any terms).\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n\n     QkObs *zero = qk_obs_zero(100);\n"]
    pub fn qk_obs_zero(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the identity observable.\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n\n     QkObs *identity = qk_obs_identity(100);\n"]
    pub fn qk_obs_identity(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct a new observable from raw data.\n\n @param num_qubits The number of qubits the observable is defined on.\n @param num_terms The number of terms.\n @param num_bits The total number of non-identity bit terms.\n @param coeffs A pointer to the first element of the coefficients array, which has length\n     ``num_terms``.\n @param bit_terms A pointer to the first element of the bit terms array, which has length\n     ``num_bits``.\n @param indices A pointer to the first element of the indices array, which has length\n     ``num_bits``. Note that, per term, these *must* be sorted incrementally.\n @param boundaries A pointer to the first element of the boundaries array, which has length\n     ``num_terms + 1``.\n\n @return If the input data was coherent and the construction successful, the result is a pointer\n     to the observable. Otherwise a null pointer is returned.\n\n # Example\n\n     // define the raw data for the 100-qubit observable |01><01|_{0, 1} - |+-><+-|_{98, 99}\n     uint32_t num_qubits = 100;\n     uint64_t num_terms = 2;  // we have 2 terms: |01><01|, -1 * |+-><+-|\n     uint64_t num_bits = 4; // we have 4 non-identity bits: 0, 1, +, -\n\n     complex double coeffs[2] = {1, -1};\n     QkBitTerm bits[4] = {QkBitTerm_Zero, QkBitTerm_One, QkBitTerm_Plus, QkBitTerm_Minus};\n     uint32_t indices[4] = {0, 1, 98, 99};  // <-- e.g. {1, 0, 99, 98} would be invalid\n     size_t boundaries[3] = {0, 2, 4};\n\n     QkObs *obs = qk_obs_new(\n         num_qubits, num_terms, num_bits, coeffs, bits, indices, boundaries\n     );\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n   * ``coeffs`` is a pointer to a ``complex double`` array of length ``num_terms``\n   * ``bit_terms`` is a pointer to an array of valid ``QkBitTerm`` elements of length ``num_bits``\n   * ``indices`` is a pointer to a ``uint32_t`` array of length ``num_bits``, which is\n     term-wise sorted in strict ascending order, and every element is smaller than ``num_qubits``\n   * ``boundaries`` is a pointer to a ``size_t`` array of length ``num_terms + 1``, which is\n     sorted in ascending order, the first element is 0 and the last element is\n     smaller than ``num_terms``"]
    pub fn qk_obs_new(
        num_qubits: u32,
        num_terms: u64,
        num_bits: u64,
        coeffs: *mut QkComplex64,
        bit_terms: *mut QkBitTerm,
        indices: *mut u32,
        boundaries: *mut usize,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free the observable.\n\n @param obs A pointer to the observable to free.\n\n # Example\n\n     QkObs *obs = qk_obs_zero(100);\n     qk_obs_free(obs);\n\n # Safety\n\n Behavior is undefined if ``obs`` is not either null or a valid pointer to a ``QkObs``."]
    pub fn qk_obs_free(obs: *mut QkObs);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add a term to the observable.\n\n @param obs A pointer to the observable.\n @param cterm A pointer to the term to add.\n\n @return An exit code. This is ``>0`` if the term is incoherent or adding the term fails.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n\n     int exit_code = qk_obs_add_term(obs, &term);\n\n # Safety\n\n Behavior is undefined if any of the following is violated:\n\n   * ``obs`` is a valid, non-null pointer to a ``QkObs``\n   * ``cterm`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_add_term(obs: *mut QkObs, cterm: *const QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get an observable term by reference.\n\n A ``QkObsTerm`` contains pointers to the indices and bit terms in the term, which\n can be used to modify the internal data of the observable. This can leave the observable\n in an incoherent state and should be avoided, unless great care is taken. It is generally\n safer to construct a new observable instead of attempting in-place modifications.\n\n @param obs A pointer to the observable.\n @param index The index of the term to get.\n @param out A pointer to a ``QkObsTerm`` used to return the observable term.\n\n @return An exit code.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     int exit_code = qk_obs_term(obs, 0, &term);\n     // out-of-bounds indices return an error code\n     // int error = qk_obs_term(obs, 12, &term);\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``out`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_term(obs: *mut QkObs, index: u64, out: *mut QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of terms in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t num_terms = qk_obs_num_terms(obs);  // num_terms==1\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_terms(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of qubits the observable is defined on.\n\n @param obs A pointer to the observable.\n\n @return The number of qubits the observable is defined on.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     uint32_t num_qubits = qk_obs_num_qubits(obs);  // num_qubits==100\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_qubits(obs: *const QkObs) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of bit terms/indices in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t len = qk_obs_len(obs);  // len==0, as there are no non-trivial bit terms\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_len(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the coefficients.\n\n This can be used to read and modify the observable's coefficients. The resulting\n pointer is valid to read for ``qk_obs_num_terms(obs)`` elements of ``complex double``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the coefficients.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t num_terms = qk_obs_num_terms(obs);\n     complex double *coeffs = qk_obs_coeffs(obs);\n\n     for (size_t i = 0; i < num_terms; i++) {\n         printf(\"%f + i%f\\n\", creal(coeffs[i]), cimag(coeffs[i]));\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_coeffs(obs: *mut QkObs) -> *mut QkComplex64;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the indices.\n\n This can be used to read and modify the observable's indices. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint32_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the indices.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_T len = qk_obs_len(obs);\n     uint32_t *indices = qk_obs_indices(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"index %i: %i\\n\", i, indices[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_indices(obs: *mut QkObs) -> *mut u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the term boundaries.\n\n This can be used to read and modify the observable's term boundaries. The resulting pointer is\n valid to read for ``qk_obs_num_terms(obs) + 1`` elements of size ``size_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the boundaries.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t num_terms = qk_obs_num_terms(obs);\n     uint32_t *boundaries = qk_obs_boundaries(obs);\n\n     for (size_t i = 0; i < num_terms + 1; i++) {\n         printf(\"boundary %i: %i\\n\", i, boundaries[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_boundaries(obs: *mut QkObs) -> *mut usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the bit terms.\n\n This can be used to read and modify the observable's bit terms. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint8_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the bit terms.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t len = qk_obs_len(obs);\n     QkBitTerm *bits = qk_obs_bit_terms(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"bit term %i: %i\\n\", i, bits[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``,\n or if invalid valus are written into the resulting ``QkBitTerm`` pointer."]
    pub fn qk_obs_bit_terms(obs: *mut QkObs) -> *mut QkBitTerm;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Multiply the observable by a complex coefficient.\n\n @param obs A pointer to the observable.\n @param coeff The coefficient to multiply the observable with.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     complex double coeff = 2;\n     QkObs *result = qk_obs_multiply(obs, &coeff);\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``coeff`` is a valid, non-null pointer to a ``complex double``"]
    pub fn qk_obs_multiply(obs: *const QkObs, coeff: *const QkComplex64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add two observables.\n\n @param left A pointer to the left observable.\n @param right A pointer to the right observable.\n\n @return A pointer to the result ``left + right``.\n\n # Example\n\n     QkObs *left = qk_obs_identity(100);\n     QkObs *right = qk_obs_zero(100);\n     QkObs *result = qk_obs_add(left, right);\n\n # Safety\n\n Behavior is undefined if ``left`` or ``right`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_add(left: *const QkObs, right: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables.\n\n @param first One observable.\n @param second The other observable.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n\n # Safety\n\n Behavior is undefined if ``first`` or ``second`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_compose(first: *const QkObs, second: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables according to a custom qubit order.\n\n Notably, this allows composing two observables of different size.\n\n @param first One observable.\n @param second The other observable. The number of qubits must match the length of ``qargs``.\n @param qargs The qubit arguments specified which indices in ``first`` to associate with\n     the ones in ``second``.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n\n # Safety\n\n To call this function safely\n\n   * ``first`` and ``second`` must be valid, non-null pointers to ``QkObs``\\ s\n   * ``qargs`` must point to an array of ``uint32_t``, readable for ``qk_obs_num_qubits(second)``\n     elements (meaning the number of qubits in ``second``)"]
    pub fn qk_obs_compose_map(
        first: *const QkObs,
        second: *const QkObs,
        qargs: *const u32,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Calculate the canonical representation of the observable.\n\n @param obs A pointer to the observable.\n @param tol The tolerance below which coefficients are considered to be zero.\n\n @return The canonical representation of the observable.\n\n # Example\n\n     QkObs *iden = qk_obs_identity(100);\n     QkObs *two = qk_obs_add(iden, iden);\n\n     double tol = 1e-6;\n     QkObs *canonical = qk_obs_canonicalize(two);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_canonicalize(obs: *const QkObs, tol: f64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Copy the observable.\n\n @param obs A pointer to the observable.\n\n @return A pointer to a copy of the observable.\n\n # Example\n\n     QkObs *original = qk_obs_identity(100);\n     QkObs *copied = qk_obs_copy(original);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_copy(obs: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compare two observables for equality.\n\n Note that this does not compare mathematical equality, but data equality. This means\n that two observables might represent the same observable but not compare as equal.\n\n @param obs A pointer to one observable.\n @param other A pointer to another observable.\n\n @return ``true`` if the observables are equal, ``false`` otherwise.\n\n # Example\n\n     QkObs *observable = qk_obs_identity(100);\n     QkObs *other = qk_obs_identity(100);\n     bool are_equal = qk_obs_equal(observable, other);\n\n # Safety\n\n Behavior is undefined if ``obs`` or ``other`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_equal(obs: *const QkObs, other: *const QkObs) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Return a string representation of a ``QkObs``.\n\n @param obs A pointer to the ``QkObs`` to get the string for.\n\n @return A pointer to a nul-terminated char array of the string representation for ``obs``\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     char *string = qk_obs_str(obs);\n     qk_str_free(string);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned (by writing a nul byte somewhere\n inside the string or removing the final one), although values can be mutated."]
    pub fn qk_obs_str(obs: *const QkObs) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free a string representation.\n\n @param string A pointer to the returned string representation from ``qk_obs_str`` or\n     ``qk_obsterm_str``.\n\n # Safety\n\n Behavior is undefined if ``str`` is not a pointer returned by ``qk_obs_str`` or\n ``qk_obsterm_str``."]
    pub fn qk_str_free(string: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObsTerm\n Return a string representation of the sparse term.\n\n @param term A pointer to the term.\n\n @return The function exit code. This is ``>0`` if reading the term failed.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     qk_obs_term(obs, 0, &term);\n     char *string = qk_obsterm_str(&term);\n     qk_str_free(string);\n\n # Safety\n\n Behavior is undefined ``term`` is not a valid, non-null pointer to a ``QkObsTerm``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned, although values can be mutated."]
    pub fn qk_obsterm_str(term: *const QkObsTerm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkBitTerm\n Get the label for a bit term.\n\n @param bit_term The bit term.\n\n @return The label as ``uint8_t``, which can be cast to ``char`` to obtain the character.\n\n # Example\n\n     QkBitTerm bit_term = QkBitTerm_Y;\n     // cast the uint8_t to char\n     char label = qk_bitterm_label(bit_term);\n\n # Safety\n\n The behavior is undefined if ``bit_term`` is not a valid ``uint8_t`` value of a ``QkBitTerm``."]
    pub fn qk_bitterm_label(bit_term: QkBitTerm) -> u8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
