/* automatically generated by rust-bindgen 0.71.1 */

#![allow(dead_code)]

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}

pub type QkComplex32 = __BindgenComplex<f32>;
pub type QkComplex64 = __BindgenComplex<f64>;
pub type QkGate = u8;
pub type QkBitTerm = u8;
pub type QkExitCode = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCount {
    pub name: *const ::std::os::raw::c_char,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCount"][::std::mem::size_of::<QkOpCount>() - 16usize];
    ["Alignment of QkOpCount"][::std::mem::align_of::<QkOpCount>() - 8usize];
    ["Offset of field: QkOpCount::name"][::std::mem::offset_of!(QkOpCount, name) - 0usize];
    ["Offset of field: QkOpCount::count"][::std::mem::offset_of!(QkOpCount, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCounts {
    pub data: *mut QkOpCount,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCounts"][::std::mem::size_of::<QkOpCounts>() - 16usize];
    ["Alignment of QkOpCounts"][::std::mem::align_of::<QkOpCounts>() - 8usize];
    ["Offset of field: QkOpCounts::data"][::std::mem::offset_of!(QkOpCounts, data) - 0usize];
    ["Offset of field: QkOpCounts::len"][::std::mem::offset_of!(QkOpCounts, len) - 8usize];
};
#[doc = " @ingroup QkCircuit\n\n A circuit instruction representation.\n\n This struct represents the data contained in an individual instruction in a ``QkCircuit``.\n It is not a pointer to the underlying object, but contains a copy of the properties of the\n instruction for inspection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuitInstruction {
    #[doc = " The instruction name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The number of qubits for this instruction."]
    pub num_qubits: u32,
    #[doc = " A pointer to an array of qubit indices this instruction operates on."]
    pub qubits: *mut u32,
    #[doc = " The number of clbits for this instruction."]
    pub num_clbits: u32,
    #[doc = " A pointer to an array of clbit indices this instruction operates on."]
    pub clbits: *mut u32,
    #[doc = " The number of parameters for this instruction."]
    pub num_params: u32,
    #[doc = " A pointer to an array of parameter values for this instruction."]
    pub params: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkCircuitInstruction"][::std::mem::size_of::<QkCircuitInstruction>() - 56usize];
    ["Alignment of QkCircuitInstruction"][::std::mem::align_of::<QkCircuitInstruction>() - 8usize];
    ["Offset of field: QkCircuitInstruction::name"]
        [::std::mem::offset_of!(QkCircuitInstruction, name) - 0usize];
    ["Offset of field: QkCircuitInstruction::num_qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_qubits) - 8usize];
    ["Offset of field: QkCircuitInstruction::qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, qubits) - 16usize];
    ["Offset of field: QkCircuitInstruction::num_clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_clbits) - 24usize];
    ["Offset of field: QkCircuitInstruction::clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, clbits) - 32usize];
    ["Offset of field: QkCircuitInstruction::num_params"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_params) - 40usize];
    ["Offset of field: QkCircuitInstruction::params"]
        [::std::mem::offset_of!(QkCircuitInstruction, params) - 48usize];
};
#[doc = " A term in a ``QkObs``.\n\n This contains the coefficient (``coeff``), the number of qubits of the observable\n (``num_qubits``) and pointers to the ``bit_terms`` and ``indices`` arrays, which have\n length ``len``. It's the responsibility of the user that the data is coherent,\n see also the below section on safety.\n\n # Safety\n\n * ``bit_terms`` must be a non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``.\n * ``indices`` must be a non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObsTerm {
    #[doc = " The coefficient of the observable term."]
    pub coeff: QkComplex64,
    #[doc = " Length of the ``bit_terms`` and ``indices`` arrays."]
    pub len: usize,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``."]
    pub bit_terms: *mut QkBitTerm,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
    pub indices: *mut u32,
    #[doc = " The number of qubits the observable term is defined on."]
    pub num_qubits: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkObsTerm"][::std::mem::size_of::<QkObsTerm>() - 48usize];
    ["Alignment of QkObsTerm"][::std::mem::align_of::<QkObsTerm>() - 8usize];
    ["Offset of field: QkObsTerm::coeff"][::std::mem::offset_of!(QkObsTerm, coeff) - 0usize];
    ["Offset of field: QkObsTerm::len"][::std::mem::offset_of!(QkObsTerm, len) - 16usize];
    ["Offset of field: QkObsTerm::bit_terms"]
        [::std::mem::offset_of!(QkObsTerm, bit_terms) - 24usize];
    ["Offset of field: QkObsTerm::indices"][::std::mem::offset_of!(QkObsTerm, indices) - 32usize];
    ["Offset of field: QkObsTerm::num_qubits"]
        [::std::mem::offset_of!(QkObsTerm, num_qubits) - 40usize];
};
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Construct a new circuit with the given number of qubits and clbits.\n\n @param num_qubits The number of qubits the circuit contains.\n @param num_clbits The number of clbits the circuit contains.\n\n @return A pointer to the created circuit.\n\n # Example\n\n     QkCircuit *empty = qk_circuit_new(100, 100);\n"]
    pub fn qk_circuit_new(num_qubits: u32, num_clbits: u32) -> *mut QkCircuit;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     uint32_t num_qubits = qk_circuit_num_qubits(qc);  // num_qubits==100\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_qubits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of clbits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 50);\n     uint32_t num_clbits = qk_circuit_num_clbits(qc);  // num_clbits==50\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_clbits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free the circuit.\n\n @param circuit A pointer to the circuit to free.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 100);\n     qk_circuit_free(qc);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not either null or a valid pointer to a\n [CircuitData]."]
    pub fn qk_circuit_free(circuit: *mut QkCircuit);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a standard gate to the circuit.\n\n @param circuit A pointer to the circuit to add the gate to.\n @param gate The StandardGate to add to the circuit.\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the gate on. This\n     can be a null pointer if there are no qubits for `gate` (e.g. `QkGate_GlobalPhase`)\n @param params The pointer to the array of ``double`` values to use for the gate parameters.\n     This can be a null pointer if there are no parameters for `gate` (e.g. `QkGate_H`).\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, HGate, *[0], *[]);\n\n # Safety\n\n The ``qubits`` and ``params`` types are expected to be a pointer to an array of ``uint32_t``\n and ``double`` respectively where the length is matching the expectations for the standard\n gate. If the array is insufficently long the behavior of this function is undefined as this\n will read outside the bounds of the array. It can be a null pointer if there are no qubits\n or params for a given gate. You can check `qk_gate_num_qubits` and `qk_gate_num_params` to\n determine how many qubits and params are required for a given gate.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_gate(
        circuit: *mut QkCircuit,
        gate: QkGate,
        qubits: *const u32,
        params: *const f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits for a `QkGate`\n\n @param gate The standard gate to get the number of qubits for\n\n # Example\n\n     uint32_t num_qubits = qk_gate_num_qubits(QkGate_CCX);\n"]
    pub fn qk_gate_num_qubits(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of params for a `QkGate`\n\n @param gate The standard gate to get the number of qubits for\n\n # Example\n\n     uint32_t num_params = qk_gate_num_params(QkGate_R);\n"]
    pub fn qk_gate_num_params(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a measurement to the circuit\n\n @param circuit A pointer to the circuit to add the measurement to\n @param qubits The ``uint32_t`` for the qubit to measure\n @param clbits The ``uint32_t`` for the clbit to store the measurement outcome in\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100, 1);\n     qk_circuit_measure(qc, 0, 0);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_measure(circuit: *mut QkCircuit, qubit: u32, clbit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a reset to the circuit\n\n @param circuit A pointer to the circuit to add the reset to\n @param qubits The ``uint32_t`` for the qubit to reset\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_reset(qc, 0);\n\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_reset(circuit: *mut QkCircuit, qubit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a barrier to the circuit\n\n @param circuit A pointer to the circuit to add the barrier to\n @param num_qubits The number of qubits wide the barrier is\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the barrier on.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     uint32_t qubits[5] = {0, 1, 2, 3, 4};\n     qk_circuit_barrier(qc, 5, qubits);\n\n # Safety\n\n The length of the array qubits points to must be num_qubits. If there is\n a mismatch the behavior is undefined.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_barrier(
        circuit: *mut QkCircuit,
        num_qubits: u32,
        qubits: *const u32,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return a list of string names for instructions in a circuit and their counts.\n\n @param circuit A pointer to the circuit to get the counts for.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, HGate, *[0], *[]);\n     qk_circuit_count_ops(qc);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_count_ops(circuit: *const QkCircuit) -> QkOpCounts;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the number of instructions in the circuit\n\n @param circuit A pointer to the circuit to get the total number of instructions for.\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, QkGate_H, *[0], *[]);\n     qk_circuit_num_instructions(qc); // 1\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_instructions(circuit: *const QkCircuit) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the instruction details for an instruction in the circuit\n\n This function is used to get the instruction details for a given instruction in\n the circuit. It returns\n\n @param circuit A pointer to the circuit to get the instruction details for.\n @param index The instruction index to get the instruction details of.\n\n @return The instruction details for the specified instructions\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(100);\n     qk_circuit_gate(qc, QkGate_H, *[0], *[]);\n     QkCircuitInstruction inst = qk_circuit_get_instruction(qc, 0);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``. The\n value for ``index`` must be less than the value returned by `qk_circuit_num_instructions`\n otherwise this function will panic"]
    pub fn qk_circuit_get_instruction(
        circuit: *const QkCircuit,
        index: usize,
    ) -> QkCircuitInstruction;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free a circuit instruction object\n\n @param inst The instruction to free\n\n # Safety\n Behavior is undefined if ``inst`` is not an object returned by ``qk_circuit_get_instruction``."]
    pub fn qk_circuit_instruction_free(inst: QkCircuitInstruction);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free a circuit op count list.\n\n @param op_counts The returned op count list from ``qk_circuit_count_ops``.\n\n # Safety\n\n Behavior is undefined if ``op_counts`` is not the object returned by ``qk_circuit_count_ops``."]
    pub fn qk_opcounts_free(op_counts: QkOpCounts);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the zero observable (without any terms).\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n\n     QkObs *zero = qk_obs_zero(100);\n"]
    pub fn qk_obs_zero(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the identity observable.\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n\n     QkObs *identity = qk_obs_identity(100);\n"]
    pub fn qk_obs_identity(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct a new observable from raw data.\n\n @param num_qubits The number of qubits the observable is defined on.\n @param num_terms The number of terms.\n @param num_bits The total number of non-identity bit terms.\n @param coeffs A pointer to the first element of the coefficients array, which has length\n     ``num_terms``.\n @param bit_terms A pointer to the first element of the bit terms array, which has length\n     ``num_bits``.\n @param indices A pointer to the first element of the indices array, which has length\n     ``num_bits``. Note that, per term, these *must* be sorted incrementally.\n @param boundaries A pointer to the first element of the boundaries array, which has length\n     ``num_terms + 1``.\n\n @return If the input data was coherent and the construction successful, the result is a pointer\n     to the observable. Otherwise a null pointer is returned.\n\n # Example\n\n     // define the raw data for the 100-qubit observable |01><01|_{0, 1} - |+-><+-|_{98, 99}\n     uint32_t num_qubits = 100;\n     uint64_t num_terms = 2;  // we have 2 terms: |01><01|, -1 * |+-><+-|\n     uint64_t num_bits = 4; // we have 4 non-identity bits: 0, 1, +, -\n\n     complex double coeffs[2] = {1, -1};\n     QkBitTerm bits[4] = {QkBitTerm_Zero, QkBitTerm_One, QkBitTerm_Plus, QkBitTerm_Minus};\n     uint32_t indices[4] = {0, 1, 98, 99};  // <-- e.g. {1, 0, 99, 98} would be invalid\n     size_t boundaries[3] = {0, 2, 4};\n\n     QkObs *obs = qk_obs_new(\n         num_qubits, num_terms, num_bits, coeffs, bits, indices, boundaries\n     );\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n   * ``coeffs`` is a pointer to a ``complex double`` array of length ``num_terms``\n   * ``bit_terms`` is a pointer to an array of valid ``QkBitTerm`` elements of length ``num_bits``\n   * ``indices`` is a pointer to a ``uint32_t`` array of length ``num_bits``, which is\n     term-wise sorted in strict ascending order, and every element is smaller than ``num_qubits``\n   * ``boundaries`` is a pointer to a ``size_t`` array of length ``num_terms + 1``, which is\n     sorted in ascending order, the first element is 0 and the last element is\n     smaller than ``num_terms``"]
    pub fn qk_obs_new(
        num_qubits: u32,
        num_terms: u64,
        num_bits: u64,
        coeffs: *mut QkComplex64,
        bit_terms: *mut QkBitTerm,
        indices: *mut u32,
        boundaries: *mut usize,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free the observable.\n\n @param obs A pointer to the observable to free.\n\n # Example\n\n     QkObs *obs = qk_obs_zero(100);\n     qk_obs_free(obs);\n\n # Safety\n\n Behavior is undefined if ``obs`` is not either null or a valid pointer to a ``QkObs``."]
    pub fn qk_obs_free(obs: *mut QkObs);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add a term to the observable.\n\n @param obs A pointer to the observable.\n @param cterm A pointer to the term to add.\n\n @return An exit code. This is ``>0`` if the term is incoherent or adding the term fails.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n\n     int exit_code = qk_obs_add_term(obs, &term);\n\n # Safety\n\n Behavior is undefined if any of the following is violated:\n\n   * ``obs`` is a valid, non-null pointer to a ``QkObs``\n   * ``cterm`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_add_term(obs: *mut QkObs, cterm: *const QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get an observable term by reference.\n\n A ``QkObsTerm`` contains pointers to the indices and bit terms in the term, which\n can be used to modify the internal data of the observable. This can leave the observable\n in an incoherent state and should be avoided, unless great care is taken. It is generally\n safer to construct a new observable instead of attempting in-place modifications.\n\n @param obs A pointer to the observable.\n @param index The index of the term to get.\n @param out A pointer to a ``QkObsTerm`` used to return the observable term.\n\n @return An exit code.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     int exit_code = qk_obs_term(obs, 0, &term);\n     // out-of-bounds indices return an error code\n     // int error = qk_obs_term(obs, 12, &term);\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``out`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_term(obs: *mut QkObs, index: u64, out: *mut QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of terms in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t num_terms = qk_obs_num_terms(obs);  // num_terms==1\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_terms(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of qubits the observable is defined on.\n\n @param obs A pointer to the observable.\n\n @return The number of qubits the observable is defined on.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     uint32_t num_qubits = qk_obs_num_qubits(obs);  // num_qubits==100\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_qubits(obs: *const QkObs) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of bit terms/indices in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t len = qk_obs_len(obs);  // len==0, as there are no non-trivial bit terms\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_len(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the coefficients.\n\n This can be used to read and modify the observable's coefficients. The resulting\n pointer is valid to read for ``qk_obs_num_terms(obs)`` elements of ``complex double``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the coefficients.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     size_t num_terms = qk_obs_num_terms(obs);\n     complex double *coeffs = qk_obs_coeffs(obs);\n\n     for (size_t i = 0; i < num_terms; i++) {\n         printf(\"%f + i%f\\n\", creal(coeffs[i]), cimag(coeffs[i]));\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_coeffs(obs: *mut QkObs) -> *mut QkComplex64;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the indices.\n\n This can be used to read and modify the observable's indices. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint32_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the indices.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_T len = qk_obs_len(obs);\n     uint32_t *indices = qk_obs_indices(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"index %i: %i\\n\", i, indices[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_indices(obs: *mut QkObs) -> *mut u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the term boundaries.\n\n This can be used to read and modify the observable's term boundaries. The resulting pointer is\n valid to read for ``qk_obs_num_terms(obs) + 1`` elements of size ``size_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the boundaries.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t num_terms = qk_obs_num_terms(obs);\n     uint32_t *boundaries = qk_obs_boundaries(obs);\n\n     for (size_t i = 0; i < num_terms + 1; i++) {\n         printf(\"boundary %i: %i\\n\", i, boundaries[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_boundaries(obs: *mut QkObs) -> *mut usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the bit terms.\n\n This can be used to read and modify the observable's bit terms. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint8_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the bit terms.\n\n # Example\n\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     complex double coeff = 1;\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {&coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t len = qk_obs_len(obs);\n     QkBitTerm *bits = qk_obs_bit_terms(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"bit term %i: %i\\n\", i, bits[i]);\n     }\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``,\n or if invalid valus are written into the resulting ``QkBitTerm`` pointer."]
    pub fn qk_obs_bit_terms(obs: *mut QkObs) -> *mut QkBitTerm;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Multiply the observable by a complex coefficient.\n\n @param obs A pointer to the observable.\n @param coeff The coefficient to multiply the observable with.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     complex double coeff = 2;\n     QkObs *result = qk_obs_multiply(obs, &coeff);\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``coeff`` is a valid, non-null pointer to a ``complex double``"]
    pub fn qk_obs_multiply(obs: *const QkObs, coeff: *const QkComplex64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add two observables.\n\n @param left A pointer to the left observable.\n @param right A pointer to the right observable.\n\n @return A pointer to the result ``left + right``.\n\n # Example\n\n     QkObs *left = qk_obs_identity(100);\n     QkObs *right = qk_obs_zero(100);\n     QkObs *result = qk_obs_add(left, right);\n\n # Safety\n\n Behavior is undefined if ``left`` or ``right`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_add(left: *const QkObs, right: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables.\n\n @param first One observable.\n @param second The other observable.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n\n # Safety\n\n Behavior is undefined if ``first`` or ``second`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_compose(first: *const QkObs, second: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables according to a custom qubit order.\n\n Notably, this allows composing two observables of different size.\n\n @param first One observable.\n @param second The other observable. The number of qubits must match the length of ``qargs``.\n @param qargs The qubit arguments specified which indices in ``first`` to associate with\n     the ones in ``second``.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n\n # Safety\n\n To call this function safely\n\n   * ``first`` and ``second`` must be valid, non-null pointers to ``QkObs``\\ s\n   * ``qargs`` must point to an array of ``uint32_t``, readable for ``qk_obs_num_qubits(second)``\n     elements (meaning the number of qubits in ``second``)"]
    pub fn qk_obs_compose_map(
        first: *const QkObs,
        second: *const QkObs,
        qargs: *const u32,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Calculate the canonical representation of the observable.\n\n @param obs A pointer to the observable.\n @param tol The tolerance below which coefficients are considered to be zero.\n\n @return The canonical representation of the observable.\n\n # Example\n\n     QkObs *iden = qk_obs_identity(100);\n     QkObs *two = qk_obs_add(iden, iden);\n\n     double tol = 1e-6;\n     QkObs *canonical = qk_obs_canonicalize(two);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_canonicalize(obs: *const QkObs, tol: f64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Copy the observable.\n\n @param obs A pointer to the observable.\n\n @return A pointer to a copy of the observable.\n\n # Example\n\n     QkObs *original = qk_obs_identity(100);\n     QkObs *copied = qk_obs_copy(original);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_copy(obs: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compare two observables for equality.\n\n Note that this does not compare mathematical equality, but data equality. This means\n that two observables might represent the same observable but not compare as equal.\n\n @param obs A pointer to one observable.\n @param other A pointer to another observable.\n\n @return ``true`` if the observables are equal, ``false`` otherwise.\n\n # Example\n\n     QkObs *observable = qk_obs_identity(100);\n     QkObs *other = qk_obs_identity(100);\n     bool are_equal = qk_obs_equal(observable, other);\n\n # Safety\n\n Behavior is undefined if ``obs`` or ``other`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_equal(obs: *const QkObs, other: *const QkObs) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Return a string representation of a ``QkObs``.\n\n @param obs A pointer to the ``QkObs`` to get the string for.\n\n @return A pointer to a nul-terminated char array of the string representation for ``obs``\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     char *string = qk_obs_str(obs);\n     qk_str_free(string);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned (by writing a nul byte somewhere\n inside the string or removing the final one), although values can be mutated."]
    pub fn qk_obs_str(obs: *const QkObs) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free a string representation.\n\n @param string A pointer to the returned string representation from ``qk_obs_str`` or\n     ``qk_obsterm_str``.\n\n # Safety\n\n Behavior is undefined if ``str`` is not a pointer returned by ``qk_obs_str`` or\n ``qk_obsterm_str``."]
    pub fn qk_str_free(string: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObsTerm\n Return a string representation of the sparse term.\n\n @param term A pointer to the term.\n\n @return The function exit code. This is ``>0`` if reading the term failed.\n\n # Example\n\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     qk_obs_term(obs, 0, &term);\n     char *string = qk_obsterm_str(&term);\n     qk_str_free(string);\n\n # Safety\n\n Behavior is undefined ``term`` is not a valid, non-null pointer to a ``QkObsTerm``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned, although values can be mutated."]
    pub fn qk_obsterm_str(term: *const QkObsTerm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkBitTerm\n Get the label for a bit term.\n\n @param bit_term The bit term.\n\n @return The label as ``uint8_t``, which can be cast to ``char`` to obtain the character.\n\n # Example\n\n     QkBitTerm bit_term = QkBitTerm_Y;\n     // cast the uint8_t to char\n     char label = qk_bitterm_label(bit_term);\n\n # Safety\n\n The behavior is undefined if ``bit_term`` is not a valid ``uint8_t`` value of a ``QkBitTerm``."]
    pub fn qk_bitterm_label(bit_term: QkBitTerm) -> u8;
}
