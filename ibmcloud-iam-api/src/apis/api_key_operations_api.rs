/*
 * IAM Identity Services
 *
 * The IAM Identity Service API allows for the management of Account Settings and Identities (Service IDs, ApiKeys).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeyError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_api_keys_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApiKeysDetailsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_api_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApiKeysError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lock_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlock_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlockApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApiKeyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// Creates an API key for a UserID or service ID. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.  
pub async fn create_api_key(configuration: &configuration::Configuration, authorization: &str, create_api_key_request: models::CreateApiKeyRequest, entity_lock: Option<&str>, entity_disable: Option<&str>) -> Result<models::ApiKey, Error<CreateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_create_api_key_request = create_api_key_request;
    let p_entity_lock = entity_lock;
    let p_entity_disable = entity_disable;

    let uri_str = format!("{}/v1/apikeys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_entity_lock {
        req_builder = req_builder.header("Entity-Lock", param_value.to_string());
    }
    if let Some(param_value) = p_entity_disable {
        req_builder = req_builder.header("Entity-Disable", param_value.to_string());
    }
    req_builder = req_builder.json(&p_create_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an API key. Existing tokens will remain valid until expired. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.  
pub async fn delete_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str) -> Result<(), Error<DeleteApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/apikeys/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable an API key. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn disable_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str) -> Result<(), Error<DisableApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/apikeys/{id}/disable", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DisableApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable an API key. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn enable_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str) -> Result<(), Error<EnableApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/apikeys/{id}/disable", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the details of an API key. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn get_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str, include_history: Option<bool>, include_activity: Option<bool>) -> Result<models::ApiKey, Error<GetApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_include_history = include_history;
    let p_include_activity = include_activity;

    let uri_str = format!("{}/v1/apikeys/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_history {
        req_builder = req_builder.query(&[("include_history", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_activity {
        req_builder = req_builder.query(&[("include_activity", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the details of an API key by its value. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.  
pub async fn get_api_keys_details(configuration: &configuration::Configuration, authorization: &str, iam_api_key: Option<&str>, include_history: Option<bool>) -> Result<models::ApiKey, Error<GetApiKeysDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_iam_api_key = iam_api_key;
    let p_include_history = include_history;

    let uri_str = format!("{}/v1/apikeys/details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_history {
        req_builder = req_builder.query(&[("include_history", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_iam_api_key {
        req_builder = req_builder.header("IAM-ApiKey", param_value.to_string());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApiKeysDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the list of API key details for a given service or user IAM ID and account ID. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn list_api_keys(configuration: &configuration::Configuration, authorization: &str, account_id: Option<&str>, iam_id: Option<&str>, pagesize: Option<i32>, pagetoken: Option<&str>, scope: Option<&str>, r#type: Option<&str>, sort: Option<&str>, order: Option<&str>, include_history: Option<bool>, filter: Option<&str>) -> Result<models::ApiKeyList, Error<ListApiKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_account_id = account_id;
    let p_iam_id = iam_id;
    let p_pagesize = pagesize;
    let p_pagetoken = pagetoken;
    let p_scope = scope;
    let p_type = r#type;
    let p_sort = sort;
    let p_order = order;
    let p_include_history = include_history;
    let p_filter = filter;

    let uri_str = format!("{}/v1/apikeys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iam_id {
        req_builder = req_builder.query(&[("iam_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagesize {
        req_builder = req_builder.query(&[("pagesize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagetoken {
        req_builder = req_builder.query(&[("pagetoken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_history {
        req_builder = req_builder.query(&[("include_history", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListApiKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Locks an API key by ID. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn lock_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str) -> Result<(), Error<LockApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/apikeys/{id}/lock", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LockApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unlocks an API key by ID. Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.
pub async fn unlock_api_key(configuration: &configuration::Configuration, id: &str, authorization: &str) -> Result<(), Error<UnlockApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/apikeys/{id}/lock", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnlockApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates properties of an API key. This does NOT affect existing access tokens. Their token content will stay unchanged until the access token is refreshed. To update an API key, pass the property to be modified. To delete one property's value, pass the property with an empty value \"\". Users can manage user API keys for themself, or service ID API keys for service IDs they have access to.  
pub async fn update_api_key(configuration: &configuration::Configuration, id: &str, if_match: &str, authorization: &str, update_api_key_request: models::UpdateApiKeyRequest) -> Result<models::ApiKey, Error<UpdateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_if_match = if_match;
    let p_authorization = authorization;
    let p_update_api_key_request = update_api_key_request;

    let uri_str = format!("{}/v1/apikeys/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("If-Match", p_if_match.to_string());
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_update_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

