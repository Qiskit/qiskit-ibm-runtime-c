/*
 * IAM Identity Services
 *
 * The IAM Identity Service API allows for the management of Account Settings and Identities (Service IDs, ApiKeys).
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`delete_preferences_on_scope_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePreferencesOnScopeAccountError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_preferences_on_scope_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllPreferencesOnScopeAccountError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_preferences_on_scope_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPreferencesOnScopeAccountError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_preference_on_scope_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePreferenceOnScopeAccountError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// Delete one Identity Preference on scope 'account'.
pub async fn delete_preferences_on_scope_account(
    configuration: &configuration::Configuration,
    account_id: &str,
    iam_id: &str,
    service: &str,
    preference_id: &str,
    authorization: Option<&str>,
) -> Result<models::ExceptionResponse, Error<DeletePreferencesOnScopeAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_iam_id = iam_id;
    let p_service = service;
    let p_preference_id = preference_id;
    let p_authorization = authorization;

    let uri_str = format!(
        "{}/v1/preferences/accounts/{account_id}/identities/{iam_id}/{service}/{preference_id}",
        configuration.base_path,
        account_id = crate::apis::urlencode(p_account_id),
        iam_id = crate::apis::urlencode(p_iam_id),
        service = crate::apis::urlencode(p_service),
        preference_id = crate::apis::urlencode(p_preference_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExceptionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExceptionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePreferencesOnScopeAccountError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all Identity Preferences for one account / user combination.
pub async fn get_all_preferences_on_scope_account(
    configuration: &configuration::Configuration,
    account_id: &str,
    iam_id: &str,
    authorization: Option<&str>,
) -> Result<models::IdentityPreferencesResponse, Error<GetAllPreferencesOnScopeAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_iam_id = iam_id;
    let p_authorization = authorization;

    let uri_str = format!(
        "{}/v1/preferences/accounts/{account_id}/identities/{iam_id}",
        configuration.base_path,
        account_id = crate::apis::urlencode(p_account_id),
        iam_id = crate::apis::urlencode(p_iam_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityPreferencesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityPreferencesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllPreferencesOnScopeAccountError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get one Identity Preference on scope 'account'.
pub async fn get_preferences_on_scope_account(
    configuration: &configuration::Configuration,
    account_id: &str,
    iam_id: &str,
    service: &str,
    preference_id: &str,
    authorization: Option<&str>,
) -> Result<models::IdentityPreferenceResponse, Error<GetPreferencesOnScopeAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_iam_id = iam_id;
    let p_service = service;
    let p_preference_id = preference_id;
    let p_authorization = authorization;

    let uri_str = format!(
        "{}/v1/preferences/accounts/{account_id}/identities/{iam_id}/{service}/{preference_id}",
        configuration.base_path,
        account_id = crate::apis::urlencode(p_account_id),
        iam_id = crate::apis::urlencode(p_iam_id),
        service = crate::apis::urlencode(p_service),
        preference_id = crate::apis::urlencode(p_preference_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityPreferenceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityPreferenceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPreferencesOnScopeAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update one Identity Preference on scope 'account'. supported preferences:   The following preferences are storing values for identities inside an account,    i.e. for each account that an identity is member of, the value stored might be different.    This means, users who might be member of multiple accounts can have multiple preferences, one per account.    Identities like Service Ids or Trusted Profiles can only exist in one account,    therefore they can only have one preference inside their related account.   preference: console/landing_page     service: console     preferenceId: landing_page     supportedIdentityType: Trusted Profiles, Users     type: string     validation: valid URL (without host part), e.g. /billing or /iam   preference: console/global_left_navigation     service: console     preferenceId: global_left_navigation     supportedIdentityType: Trusted Profiles, Users     type: list of strings     validation: each entry in the list of strings must match the identifier of one navigation entry in the console
pub async fn update_preference_on_scope_account(
    configuration: &configuration::Configuration,
    account_id: &str,
    iam_id: &str,
    service: &str,
    preference_id: &str,
    update_preference_request: models::UpdatePreferenceRequest,
    authorization: Option<&str>,
) -> Result<models::IdentityPreferenceResponse, Error<UpdatePreferenceOnScopeAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_iam_id = iam_id;
    let p_service = service;
    let p_preference_id = preference_id;
    let p_update_preference_request = update_preference_request;
    let p_authorization = authorization;

    let uri_str = format!(
        "{}/v1/preferences/accounts/{account_id}/identities/{iam_id}/{service}/{preference_id}",
        configuration.base_path,
        account_id = crate::apis::urlencode(p_account_id),
        iam_id = crate::apis::urlencode(p_iam_id),
        service = crate::apis::urlencode(p_service),
        preference_id = crate::apis::urlencode(p_preference_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    req_builder = req_builder.json(&p_update_preference_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityPreferenceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityPreferenceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePreferenceOnScopeAccountError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
