/*
 * IAM Identity Services
 *
 * The IAM Identity Service API allows for the management of Account Settings and Identities (Service IDs, ApiKeys).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_claim_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateClaimRuleError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLinkError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateProfileError {
    Status400(),
    Status401(),
    Status403(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_claim_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteClaimRuleError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteLinkError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProfileError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_profile_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProfileIdentityError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_claim_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClaimRuleError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLinkError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_profile_identities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileIdentitiesError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_profile_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileIdentityError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_claim_rules`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListClaimRulesError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLinksError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_profiles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListProfilesError {
    Status400(models::ExceptionResponse),
    Status401(models::ExceptionResponse),
    Status403(models::ExceptionResponse),
    Status404(models::ExceptionResponse),
    Status500(models::ExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_profile_identities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetProfileIdentitiesError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_profile_identity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetProfileIdentityError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_claim_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateClaimRuleError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateProfileError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// Create a claim rule for a trusted profile. There is a limit of 20 rules per trusted profile.
pub async fn create_claim_rule(configuration: &configuration::Configuration, authorization: &str, profile_id: &str, profile_claim_rule_request: models::ProfileClaimRuleRequest) -> Result<models::ProfileClaimRule, Error<CreateClaimRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_profile_id = profile_id;
    let p_profile_claim_rule_request = profile_claim_rule_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}/rules", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_profile_claim_rule_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileClaimRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileClaimRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateClaimRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a direct link between a specific compute resource and a trusted profile, rather than creating conditions that a compute resource must fulfill to apply a trusted profile.
pub async fn create_link(configuration: &configuration::Configuration, profile_id: &str, authorization: &str, create_profile_link_request: models::CreateProfileLinkRequest) -> Result<models::ProfileLink, Error<CreateLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;
    let p_create_profile_link_request = create_profile_link_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}/links", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_create_profile_link_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileLink`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileLink`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a trusted profile for a given account ID.
pub async fn create_profile(configuration: &configuration::Configuration, authorization: &str, create_trusted_profile_request: models::CreateTrustedProfileRequest) -> Result<models::TrustedProfile, Error<CreateProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_create_trusted_profile_request = create_trusted_profile_request;

    let uri_str = format!("{}/v1/profiles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_create_trusted_profile_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a claim rule. When you delete a claim rule, federated user or compute resources are no longer required to meet the conditions of the claim rule in order to apply the trusted profile.
pub async fn delete_claim_rule(configuration: &configuration::Configuration, profile_id: &str, rule_id: &str, authorization: &str) -> Result<(), Error<DeleteClaimRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_rule_id = rule_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/rules/{rule_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), rule_id=crate::apis::urlencode(p_rule_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteClaimRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a link between a compute resource and a trusted profile.
pub async fn delete_link(configuration: &configuration::Configuration, profile_id: &str, link_id: &str, authorization: &str) -> Result<(), Error<DeleteLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_link_id = link_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/links/{link_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), link_id=crate::apis::urlencode(p_link_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a trusted profile. When you delete trusted profile, compute resources and federated users are unlinked from the profile and can no longer apply the trusted profile identity.
pub async fn delete_profile(configuration: &configuration::Configuration, profile_id: &str, authorization: &str) -> Result<(), Error<DeleteProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the identity that can assume the trusted profile
pub async fn delete_profile_identity(configuration: &configuration::Configuration, profile_id: &str, identity_type: &str, identifier_id: &str, authorization: &str) -> Result<(), Error<DeleteProfileIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_identity_type = identity_type;
    let p_identifier_id = identifier_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/identities/{identity_type}/{identifier_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), identity_type=crate::apis::urlencode(p_identity_type), identifier_id=crate::apis::urlencode(p_identifier_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteProfileIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A specific claim rule can be fetched for a given trusted profile ID and rule ID.
pub async fn get_claim_rule(configuration: &configuration::Configuration, profile_id: &str, rule_id: &str, authorization: &str) -> Result<models::ProfileClaimRule, Error<GetClaimRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_rule_id = rule_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/rules/{rule_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), rule_id=crate::apis::urlencode(p_rule_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileClaimRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileClaimRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClaimRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific link to a trusted profile by `link_id`.
pub async fn get_link(configuration: &configuration::Configuration, profile_id: &str, link_id: &str, authorization: &str) -> Result<models::ProfileLink, Error<GetLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_link_id = link_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/links/{link_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), link_id=crate::apis::urlencode(p_link_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileLink`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileLink`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a trusted profile by its `profile-id`. Only the trusted profile's data is returned (`name`, `description`, `iam_id`, etc.), not the federated users or compute resources that qualify to apply the trusted profile.
pub async fn get_profile(configuration: &configuration::Configuration, profile_id: &str, authorization: &str, include_activity: Option<bool>) -> Result<models::TrustedProfile, Error<GetProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;
    let p_include_activity = include_activity;

    let uri_str = format!("{}/v1/profiles/{profile_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_activity {
        req_builder = req_builder.query(&[("include_activity", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of identities that can assume the trusted profile
pub async fn get_profile_identities(configuration: &configuration::Configuration, profile_id: &str, authorization: &str) -> Result<models::ProfileIdentitiesResponse, Error<GetProfileIdentitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/identities", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileIdentitiesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileIdentitiesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProfileIdentitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the identity that can assume the trusted profile
pub async fn get_profile_identity(configuration: &configuration::Configuration, profile_id: &str, identity_type: &str, identifier_id: &str, authorization: &str) -> Result<models::ProfileIdentityResponse, Error<GetProfileIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_identity_type = identity_type;
    let p_identifier_id = identifier_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/identities/{identity_type}/{identifier_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), identity_type=crate::apis::urlencode(p_identity_type), identifier_id=crate::apis::urlencode(p_identifier_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileIdentityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileIdentityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProfileIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all claim rules for a trusted profile. The `profile-id` query parameter determines the profile from which to retrieve the list of claim rules.
pub async fn list_claim_rules(configuration: &configuration::Configuration, profile_id: &str, authorization: &str) -> Result<models::ProfileClaimRuleList, Error<ListClaimRulesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/rules", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileClaimRuleList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileClaimRuleList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListClaimRulesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of links to a trusted profile.
pub async fn list_links(configuration: &configuration::Configuration, profile_id: &str, authorization: &str) -> Result<models::ProfileLinkList, Error<ListLinksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;

    let uri_str = format!("{}/v1/profiles/{profile_id}/links", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileLinkList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileLinkList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListLinksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the trusted profiles in an account. The `account_id` query parameter determines the account from which to retrieve the list of trusted profiles.
pub async fn list_profiles(configuration: &configuration::Configuration, account_id: &str, authorization: &str, name: Option<&str>, pagesize: Option<i32>, sort: Option<&str>, order: Option<&str>, include_history: Option<bool>, pagetoken: Option<&str>, filter: Option<&str>) -> Result<models::TrustedProfilesList, Error<ListProfilesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_authorization = authorization;
    let p_name = name;
    let p_pagesize = pagesize;
    let p_sort = sort;
    let p_order = order;
    let p_include_history = include_history;
    let p_pagetoken = pagetoken;
    let p_filter = filter;

    let uri_str = format!("{}/v1/profiles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("account_id", &p_account_id.to_string())]);
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagesize {
        req_builder = req_builder.query(&[("pagesize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_history {
        req_builder = req_builder.query(&[("include_history", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagetoken {
        req_builder = req_builder.query(&[("pagetoken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedProfilesList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedProfilesList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListProfilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the list of identities that can assume the trusted profile
pub async fn set_profile_identities(configuration: &configuration::Configuration, profile_id: &str, if_match: &str, authorization: &str, profile_identities_update_request: models::ProfileIdentitiesUpdateRequest) -> Result<models::ProfileIdentitiesResponse, Error<SetProfileIdentitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_if_match = if_match;
    let p_authorization = authorization;
    let p_profile_identities_update_request = profile_identities_update_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}/identities", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("If-Match", p_if_match.to_string());
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_profile_identities_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileIdentitiesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileIdentitiesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetProfileIdentitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a specific identity that can assume the trusted profile. This API will update the trusted profile itself, thus calling it repeatedly for the same profile can lead to conflicts responded with HTTP code 409. Make sure to call this API only once in a few seconds for the same trusted profile.
pub async fn set_profile_identity(configuration: &configuration::Configuration, profile_id: &str, identity_type: &str, authorization: &str, profile_identity_request: models::ProfileIdentityRequest) -> Result<models::ProfileIdentityResponse, Error<SetProfileIdentityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_identity_type = identity_type;
    let p_authorization = authorization;
    let p_profile_identity_request = profile_identity_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}/identities/{identity_type}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), identity_type=crate::apis::urlencode(p_identity_type));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.json(&p_profile_identity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileIdentityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileIdentityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetProfileIdentityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a specific claim rule for a given trusted profile ID and rule ID.
pub async fn update_claim_rule(configuration: &configuration::Configuration, profile_id: &str, rule_id: &str, authorization: &str, if_match: &str, profile_claim_rule_request: models::ProfileClaimRuleRequest) -> Result<models::ProfileClaimRule, Error<UpdateClaimRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_rule_id = rule_id;
    let p_authorization = authorization;
    let p_if_match = if_match;
    let p_profile_claim_rule_request = profile_claim_rule_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}/rules/{rule_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id), rule_id=crate::apis::urlencode(p_rule_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.header("If-Match", p_if_match.to_string());
    req_builder = req_builder.json(&p_profile_claim_rule_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileClaimRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileClaimRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateClaimRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the name or description of an existing trusted profile.
pub async fn update_profile(configuration: &configuration::Configuration, profile_id: &str, authorization: &str, if_match: &str, update_trusted_profile_request: models::UpdateTrustedProfileRequest) -> Result<models::TrustedProfile, Error<UpdateProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_profile_id = profile_id;
    let p_authorization = authorization;
    let p_if_match = if_match;
    let p_update_trusted_profile_request = update_trusted_profile_request;

    let uri_str = format!("{}/v1/profiles/{profile_id}", configuration.base_path, profile_id=crate::apis::urlencode(p_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.header("If-Match", p_if_match.to_string());
    req_builder = req_builder.json(&p_update_trusted_profile_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedProfile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedProfile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

