/*
 * IAM Identity Services
 *
 * The IAM Identity Service API allows for the management of Account Settings and Identities (Service IDs, ApiKeys).
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`get_token_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenApiKeyError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_api_key_delegated_refresh_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenApiKeyDelegatedRefreshTokenError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_assume`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenAssumeError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_cr_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenCrTokenError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_iam_authz`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenIamAuthzError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenPasswordError {
    Status400(models::OidcExceptionResponse),
    Status401(models::OidcExceptionResponse),
    Status403(models::OidcExceptionResponse),
    Status500(models::OidcExceptionResponse),
    UnknownValue(serde_json::Value),
}

/// Creates a non-opaque access token for an API key.
pub async fn get_token_api_key(
    configuration: &configuration::Configuration,
    grant_type: &str,
    apikey: &str,
    ibm_cloud_tenant: Option<&str>,
) -> Result<models::TokenResponse, Error<GetTokenApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_apikey = apikey;
    let p_ibm_cloud_tenant = ibm_cloud_tenant;

    let uri_str = format!("{}/identity/token#apikey", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_ibm_cloud_tenant {
        req_builder = req_builder.header("ibm-cloud-tenant", param_value.to_string());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("apikey", p_apikey.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a non-opaque access token and a delegated refresh token for an API key.
pub async fn get_token_api_key_delegated_refresh_token(
    configuration: &configuration::Configuration,
    grant_type: &str,
    apikey: &str,
    response_type: &str,
    receiver_client_ids: &str,
    ibm_cloud_tenant: Option<&str>,
    delegated_refresh_token_expiry: Option<i32>,
) -> Result<models::TokenResponse, Error<GetTokenApiKeyDelegatedRefreshTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_apikey = apikey;
    let p_response_type = response_type;
    let p_receiver_client_ids = receiver_client_ids;
    let p_ibm_cloud_tenant = ibm_cloud_tenant;
    let p_delegated_refresh_token_expiry = delegated_refresh_token_expiry;

    let uri_str = format!(
        "{}/identity/token#apikey-delegated-refresh-token",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_ibm_cloud_tenant {
        req_builder = req_builder.header("ibm-cloud-tenant", param_value.to_string());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("apikey", p_apikey.to_string());
    multipart_form_params.insert("response_type", p_response_type.to_string());
    multipart_form_params.insert("receiver_client_ids", p_receiver_client_ids.to_string());
    if let Some(param_value) = p_delegated_refresh_token_expiry {
        multipart_form_params.insert("delegated_refresh_token_expiry", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenApiKeyDelegatedRefreshTokenError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a non-opaque access token for a profile.
pub async fn get_token_assume(
    configuration: &configuration::Configuration,
    grant_type: &str,
    access_token: Option<&str>,
    refresh_token: Option<&str>,
    cookie: Option<&str>,
    profile_id: Option<&str>,
    profile_name: Option<&str>,
    profile_crn: Option<&str>,
    account: Option<&str>,
) -> Result<models::TokenResponse, Error<GetTokenAssumeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_access_token = access_token;
    let p_refresh_token = refresh_token;
    let p_cookie = cookie;
    let p_profile_id = profile_id;
    let p_profile_name = profile_name;
    let p_profile_crn = profile_crn;
    let p_account = account;

    let uri_str = format!("{}/identity/token#assume", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    if let Some(param_value) = p_access_token {
        multipart_form_params.insert("access_token", param_value.to_string());
    }
    if let Some(param_value) = p_refresh_token {
        multipart_form_params.insert("refresh_token", param_value.to_string());
    }
    if let Some(param_value) = p_cookie {
        multipart_form_params.insert("cookie", param_value.to_string());
    }
    if let Some(param_value) = p_profile_id {
        multipart_form_params.insert("profile_id", param_value.to_string());
    }
    if let Some(param_value) = p_profile_name {
        multipart_form_params.insert("profile_name", param_value.to_string());
    }
    if let Some(param_value) = p_profile_crn {
        multipart_form_params.insert("profile_crn", param_value.to_string());
    }
    if let Some(param_value) = p_account {
        multipart_form_params.insert("account", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenAssumeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a non-opaque access token without a refresh token for a Trusted Profile
pub async fn get_token_cr_token(
    configuration: &configuration::Configuration,
    grant_type: &str,
    cr_token: &str,
    authorization: Option<&str>,
    ibm_cloud_tenant: Option<&str>,
    profile_id: Option<&str>,
    profile_name: Option<&str>,
    profile_crn: Option<&str>,
) -> Result<models::TokenResponse, Error<GetTokenCrTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_cr_token = cr_token;
    let p_authorization = authorization;
    let p_ibm_cloud_tenant = ibm_cloud_tenant;
    let p_profile_id = profile_id;
    let p_profile_name = profile_name;
    let p_profile_crn = profile_crn;

    let uri_str = format!("{}/identity/token#cr-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_ibm_cloud_tenant {
        req_builder = req_builder.header("ibm-cloud-tenant", param_value.to_string());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("cr_token", p_cr_token.to_string());
    if let Some(param_value) = p_profile_id {
        multipart_form_params.insert("profile_id", param_value.to_string());
    }
    if let Some(param_value) = p_profile_name {
        multipart_form_params.insert("profile_name", param_value.to_string());
    }
    if let Some(param_value) = p_profile_crn {
        multipart_form_params.insert("profile_crn", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenCrTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a non-opaque access token, if an appropriate authorization policy is in place. This kind of IAM access token is typically used for access between services.
pub async fn get_token_iam_authz(
    configuration: &configuration::Configuration,
    grant_type: &str,
    access_token: &str,
    desired_iam_id: &str,
) -> Result<models::TokenResponse, Error<GetTokenIamAuthzError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grant_type = grant_type;
    let p_access_token = access_token;
    let p_desired_iam_id = desired_iam_id;

    let uri_str = format!("{}/identity/token#iam-authz", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("access_token", p_access_token.to_string());
    multipart_form_params.insert("desired_iam_id", p_desired_iam_id.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenIamAuthzError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a non-opaque access token for a username and password. To be able to call IBM Cloud APIs, the token must be made account-specific. For this purpose, also pass the 32 character long identifier for your account in the API call. This API call is possible only for non-federated IBMid users.
pub async fn get_token_password(
    configuration: &configuration::Configuration,
    authorization: &str,
    grant_type: &str,
    username: &str,
    password: &str,
    ibm_cloud_tenant: Option<&str>,
    account: Option<&str>,
) -> Result<models::TokenResponse, Error<GetTokenPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_grant_type = grant_type;
    let p_username = username;
    let p_password = password;
    let p_ibm_cloud_tenant = ibm_cloud_tenant;
    let p_account = account;

    let uri_str = format!("{}/identity/token#password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    if let Some(param_value) = p_ibm_cloud_tenant {
        req_builder = req_builder.header("ibm-cloud-tenant", param_value.to_string());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_grant_type.to_string());
    multipart_form_params.insert("username", p_username.to_string());
    multipart_form_params.insert("password", p_password.to_string());
    if let Some(param_value) = p_account {
        multipart_form_params.insert("account", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTokenPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
